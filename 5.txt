


本章讲解 html + css

1. 什么是html？

   HTML称为超文本“标记”语言。标记就是标注的意思。(不敢兴趣的话，这句话不重要) 它包括一系列标签：比如div，a,ul,li,span,p, H标签

   答案：应该要这样理解：把HTML标签相当于一个容器，比喻成一个盒子，它可以用来盛放：文字，图片、视频、声音、表格、链接等。

2.什么是css

   css是指层叠样式表。用来修饰html标签的

  答案：应该这样理解：因为把html标签看作是一个盒子容器话，css就是用来控制这个盒子的大小，颜色，形状，位置等等的作用。

  









1.熟悉平台规则 ，不能触碰红线

2.30秒原则 ，封面+标题+关键字标签

3.打造IP， 多露脸  ： 让用户获取到值得信任的信息，而不是面对一个只会读稿子的机器

4.知道自己的定位和粉丝画像 ，他们有什么样的需求？

5. 要摸清用户的观看动机， 自我增值？

6.做每一集都要总结一下本集内容的价值，

7.要有真问题意识，在创作时候， 一定要思考用户在这个领域有什么样的问题？解决痛点，痒点

8.要有模块思维， 要开始设计具体的章节主题，延伸问题的解决方案，第一步有没有抛出问题，第二步有没有解答问题，最后是否让用户长知识了，是否有收获了，打开视野了，可以吹牛了。

9.挖掘话题性， 比如 热门话题。



1733 , 


http://172.16.4.127:8089/AFOne/AFOne.Portal.git

客户编号
183294083

用户名
jiubijiu@126.com


这个是新的前端AFOne2.0地址：
http://172.16.4.127:8089/AFOne/AFOne.Portal.git

\\Rczp-yangjun\接口文档



开机密码：Hao417788569

http://172.16.4.127:8089/users/sign_in




档案业务系统 后端代码
http://172.16.4.127:8089/AFOne/PFileSystem

{
  "UserName": "system",
  "Password": "1111"
}
git@localhost:AFOne/PFileSystem.git
====================

前端代码：
git@172.16.4.127:AFOne/Portal.git       >> 分支：Retire-File-Center  

后端代码：
git@172.16.4.127:AFOne/PFileSystem.git

页面登录：
用户名：system 
密码：1111


=====================




1 ： 集团及公司管理
           集团管理
           公司管理
           雇员管理
           文件目录设置


2 ： 系统设置
             角色管理
             账户管理
             数据权限
             用户信息


git@172.16.4.127:AFOne/Benifit_EMarket.git


前端框架： elementUi ， mintui ，vantui


SH0588  钱玮    福利中心
SH1494  沙晓雯  互联网产品中心


http://localhost:8060/#/InternetProductCenter/SpecialActivity



记得多用短路取值：
this.easing = easing || jQuery.easing._default;




git@172.16.4.127:AFOne/BenifitCenter.git  弹性福利中心，dev分支

https://yesno.wtf/api      json测试

git@172.16.4.127:AFOne/Portal.git  下载地址dev

http://172.16.4.127:8089/AFOne/BenifitCenter/tree/dev/Portal/portal/src/page  弹性福利中心


el-table-搜索功能-1.html

https://blog.csdn.net/qq_45074127/article/details/103325568


//光标处插入dom
    <el-button @click="insertDom" plain size="mini" type="primary">插入</el-button>
    <el-input type="textarea" @blur="getPosition($event)" v-model="desc"></el-input>
getPosition(e){
      this.indexP = e.srcElement.selectionStart;
    },
    insertDom(){
      let start = this.desc.substring(0,this.indexP);
      let end   = this.desc.substring(this.indexP);
      let arr = [start,this.insertValue,end];
      let res = arr.join("");
      this.desc = res;
    },


获取时间
let t = new Date();
      this.form.YearMonth = t.getFullYear() + "-" + (t.getMonth() + 1);
      this.todayDate = t.getFullYear() + "-" + (t.getMonth() + 1);





异步化为同步函数
async function fn(){
      let a = await api.GetMiProNewNo();
      let c = await new Promise((resolve,b)=>{ resolve(100); console.log(2222); });
      let b = await api.MedProChoice();
      console.log(a);
      console.log(b);
      console.log(c);
    };
    fn();
    console.log(33333);

    //执行顺序为：
    //先输出同步代码33333, 在输出Promise执行器里面的2222，再输出异步promise里面的100，再输出异步a,b里面的结果。





页面元素权限添加

第一：git查看某个文件的修改历史  :  git log --pretty=oneline 文件名

第二：git show 356f6def9d3fb7f3b9032ff5aa4b9110d4cca87e

http://172.16.4.127:8089/AFOne/Portal/commits/health_2.0

git@172.16.4.127:AFTransfer/AFTransfer.git          //这个是后端的swagger

后端server包下载：  http://172.16.4.127:8089/AFOne/service
前端包下载：            http://172.16.4.127:8089/AFOne/Portal













<el-input-number
                class="pcmaa-input"
                size="small"
                :maxlength="20"
                :min="0"
                :precision="2"
                :controls="false"
                v-model="DialogFrom.HF_Base"
                style="width:100%;"
              />

/deep/.el-input-number.is-without-controls .el-input__inner{
    text-align: left;
  }


按回车搜索：
@keyup.enter.native="querySearch"



登录开机密码：Hao123456   / Hao15921007291

登录开机密码：Hao654321


{ "invitationFile": "86bb3feb-22b1-4fec-b36b-a95ce81b90b7", "feedbackFile": "579ba1f6-39be-4e5b-836a-7f420670270b", "otherFile1": "a3598a23-f1ab-4146-bc4a-351aadb0c9b4", "otherFile2": "79c3b886-f6d8-4413-a9d4-cd39c84900db" }


        //setTimeout(()=>{this.dataObj.quotationType = response.result.form.contractCategoryId;},1);


@瘋癲牛小邪 
减免业务
api/Fw_JMYW/list
服务项目 ， 项目负责人 ，这两个字段的中文名称有空能返给我吗..
====================================
url: Fw_JMYW/{Id}??????? (获取单个)
这个接口的：公司名称 ， 参与人 ，客服人员， 这3个字段的中文名称能返给我吗.....
=====================================
另外：ApplyId 审批单号 我提交了，但是每次返回都是null



cnpm?install?--save-dev?less-loader

汤吾子:
那你接下去可以看供应商这一块了


汤吾子:
先话页面




a2ec5775-842b-4d19-afc3-08d72467d091

projectCommCompanies


http://localhost:8070/api/ProjectCommunication?projectCommunicationId=90c0785d-dab8-4ce1-bf1c-e6aa660b33


POST/api/Project/list 这个加了个参数{
  "comadmincode": "string",
  "comadminname": "string",
  "customername": "string",
  "customercode": "string",
  "projectname": "string",
  "projectcode": "string",
  "projectstatus": 0,
  "pageIndex": 0,
  "pageSize": 0
}



6222031001017228607 2019-08-10  


74
余额:122.3  16:56
     125.3  18:02
     127.6  19:01
     129.3  20:01


GET/api/ProjectEvaluate
POST/api/ProjectEvaluate/create
POST/api/ProjectEvaluate/update
POST/api/ProjectEvaluate/delete/{ProjectEvaluateId}

git@172.16.4.127:AFOne/Portal.git



VS code 修改主题设置代码对其齐线
renderIntentGuides
找到 文件-->首选项——>设置→搜索renderIntentGuides→将此选项改为true(默认为false)，就可以了。


VSCode关闭代码参考线和当前选中行高亮
1.关闭代码参考线
在设置中搜索：render Intent Guides 取消勾选


2.设置当前选中行 行号高亮
在设置中 默认是选的 line（整行高亮），我们换成 gutter（行号高亮）
在设置中搜索：render line Highlight
选择：gutter


kai ji mi ma
AAAaaa1234
\\172.16.4.33\部门共享\张军\Microsoft Visual Studio


gif地址：
操作：在所在文件夹 右键git bash
浏览器打开网址：http://172.16.4.127:8089/groups/AFOne
请选择：SSH： 地址： git@172.16.4.127:AFOne/Prototype.git
然后在gif中输入：$ gif clone git@172.16.4.127:AFOne/Prototype.git 
用户名：wb.yejl@ciicsh.com
mimi: Hao417788569




git@172.16.4.127:AFOne/Portal.git



DictionaryManage.vue DictionaryQuery.vue FeeManage.vue dictionaryManage.less dictionaryQuery.less feeManage.less






===========================================================================
dianying44.com
dianying00.com
dianying003.com
dianyingban.com
dianyingxian.com
dianyingmin.com
dy8y.com
dy8t.com.
dy8b.com
dy4008.com





https://www.liaoxuefeng.com/wiki/896043488029600/900375748016320

=============================================================================
git add指定文件----例如：git add feeManage.css feeGood.css



要查看远程库的信息，用git remote：
$ git remote
origin


或者，用git remote -v显示更详细的信息：
$ git remote -v
origin  git@github.com:michaelliao/learngit.git (fetch)
origin  git@github.com:michaelliao/learngit.git (push)

===============================================================================
因此，多人协作的工作模式通常是这样
1.首先，可以试图用git push origin <branch-name>推送自己的修改；   //记得加上origin 关键字
如果推送失败，则因为远程分支比你的本地更新，需要先用git pull试图合并；

2.如果合并有冲突，则解决冲突，并在本地提交；

3.没有冲突或者解决掉冲突后，再用git push origin <branch-name>推送就能成功！

4.如果git pull提示no tracking information，则说明本地分支和远程分支的链接关系没有创建，用命令git branch --set-upstream-to <branch-name> origin/<branch-name>。

5.这就是多人协作的工作模式，一旦熟悉了，就非常简单。


===========================================================

当官当久了有时候就只有职权，没有义务和纪律了

你是不是带着性别歧视在执法，是不是带着有色眼镜在执法，是不是带着情绪在执法，是不是带着完成指标在执法

某些人尝到了权利的滋味，就更加的猖狂了

我作为中华人民共和国合格守法的公民，我的人格尊严不是用来被你如此践踏。

是人民给你的权利，你却反咬人民一口

在拍摄不影响正常执法的情况下，民警要自觉接受监督，要习惯在“镜头”下执法

遇到群众对查验身份证不理解的情况，民警应该使用文明规范用语，做好解释工作

一方面，民警要依法依规进行查验，明确查验范围，增强针对性，减少随意性；另一方面，公民有配合查验的法定义务。

民众在公共场合录像记录公共事务是合理的。何况公民有监督权呢。

警察执法时，公民bai可以对其du执法过程进行录音录像。这zhi是公民的监督权

公安部治安管理局、户政管理研究中心负责人关于社会舆论高度关注人民警察查验居民身份证等问题作出解释：人民警察依法查验居民身份证，首先要表明身份并出示执法证件；在执法过程中，要始终做到理性、平和、文明、规范执法，因情施策，确保安全。

《公安机关人民警察着装管理规定》
　　第十一条 公安民警着装时，应当随身携带《公安机关人民警察证》。

《公安机关人民警察内务条令》
(三)在依法执行职务时，除法律、法规另有规定外，公安民警应当随身携带证件，并主动出示以表明人民警察身份。


第十五条人民警察依法执行职务，遇有下列情形之一的，经出示执法证件，可以查验居民身份证：

    （一）对有违法犯罪嫌疑的人员，需要查明身份的；

    （二）依法实施现场管制时，需要查明有关人员身份的；

    （三）发生严重危害社会治安突发事件时，需要查明现场有关人员身份的；

    （四）在火车站、长途汽车站、港口、码头、机场或者在重大活动期间设区的市级人民政府规定的场所，需要查明有关人员身份的；

    （五）法律规定需要查明身份的其他情形。

    有前款所列情形之一，拒绝人民警察查验居民身份证的，依照有关法律规定，分别不同情形，采取措施予以处理。

    任何组织或者个人不得扣押居民身份证。但是，公安机关依照《中华人民共和国刑事诉讼法》执行监视居住强制措施的情形除外。


首先bai，公民用手机拍摄执法机关的行为不违反任何du法zhi律规定，任何执法机关在执法的时候除涉及国家秘dao密之外，任何公民和组织均有权进行以各种方式监督，而且，如果发现行政机关的违法行为，有权提出质疑，曝光，以让社会大众知晓，如果违法行为是针对自己或影响到自己利益的，还可以提起行政复议和行政诉讼。温总理说，要创造条件让人民监督政府。因此，公安局不仅不应当阻拦，而且还应敞开大门，欢迎和鼓励公民以各种方式包括拍摄的方式进行监督，这与有没有记者证等没有任何关系。
　　其次，警察强行删除拍摄的内容是违法的。因为拍摄也是合法监督或鼓励方式之一，因此，警察应当予以尊重和欢迎。如果警察的执法是正当的和合法的，对于公民的拍摄，不应当有任何疑惑或顾虑，警察根本没有权利对拍摄的手机或相机进行检查甚至删除，这种检查和删除行为从法律上讲也是一种行政行为，但是是一种违法行政行为，针对这种违法行政行为，公民有权提起行政复议和行政诉讼，要求确认这种行为违法，并公开赔礼道歉。
　　我国的行政机关从法律上讲是应当接受公民监督的，而且每一个每一级的行政机关都会表示欢迎社会各界进行依法监督。任何单位和个人都应当自律，但是不能完全相信自律，他律才是最重要的，公民强有力的监督才是最重要的他律，政府执法机关能不能有效地执行法律，能不能真正有效的为人民服务，真正当好人民的“仆人”，在很大程度上取决于对他们强有力的监督，这也是目前能够做到的。


人民警察依法执行职务，遇有下列情形之一的，
经出示执法证件，可以查验居民身份证： 
（一）对有违法犯罪嫌疑的人员，需要查明身份的；
 （二）依法实施现场管制时，需要查明有关人员身份的；
 （三）发生严重危害社会治安突发事件时，需要查明现场有关人员身份的； 
（四）在火车站、长途汽车站、港口、码头、机场或者在重大活动期间设区的市级人民政府规定的场所，需要查明有关人员身份的； 
（五）法律规定需要查明身份的其他情形。 
有前款所列情形之一，拒绝人民警察查验居民身份证的，依照有关法律规定，分别不同情形，采取措施予以处理。
 任何组织或者个人不得扣押居民身份证。
但是，公安机关依照《中华人民共和国刑事诉讼法》执行监视居住强制措施的情形除外。


公安部要求，各地公安机关要进一步研究细化执法情形和执法规范，不断提升执法能力和执法水平，努力让人民群众在每一项执法活动、每一起案件办理中感受到公平正义。





===========================================================



小结
查看远程库信息，使用git remote -v；

本地新建的分支如果不推送到远程，对其他人就是不可见的；

从本地推送分支，使用git push origin branch-name，如果推送失败，先用git pull抓取远程的新提交；

在本地创建和远程分支对应的分支，使用git checkout -b branch-name origin/branch-name，本地和远程分支的名称最好一致；

建立本地分支和远程分支的关联，使用git branch --set-upstream branch-name origin/branch-name；

从远程抓取分支，使用git pull，如果有冲突，要先处理冲突。





=====================================================================
https://www.liaoxuefeng.com/wiki/896043488029600/900003767775424


Git鼓励大量使用分支：

查看分支：git branch

创建分支：git branch <name>

切换分支：git checkout <name>

创建+切换分支：git checkout -b <name>

合并某分支到当前分支：git merge <name>

删除分支：git branch -d <name>



========================================================================================================





工作认真负责态度好，能高质量的完成任务，能及时完成上级交待的工作任务。


中国平安科技部：
项目名称：中国信托登记有限公司
运用到的技术栈：vue，js，sass，css, html, json, svn
项目流程：由客户提供需求，然后由产品经理画出原型，再生成文档交给前端开发。
项目内容：中国信托登记公司，管理着全国数家信托机构，为了规范信托行业，就开发了信托登记平台。
          需要办理信托的客户或者企业来到这个平台注册账户：
          业务流程为：
          开户申请--变更申请--提交资料---上传资料--修改资料
          平台审核--通过或者退回--详情页面
          客户注销等等一系列流程。
          角色还分为：超级管理员，中信登申请岗，中信登审核岗，查询岗，代理机构申请岗，代理机构审核岗，代理机构查询岗等等
工作内容：通过产品文档，用html+css+js画出原型界面，再通过后台返回的api接口数据，然后通过vue对数据进行双向绑定
          在前端展示数据或者提交数据到Java后台。

描述：本项目前后端半分离状态，老的页面当中含有angularJs，新的页面采用vueJs来替代它。同时页面当中含有jsp代码。jQuery代码。
      前后端数据交流还是通过API接口交互。项目的版本控制主要用SVN。样式用sass。



this.#set(obj, key, value)

学习资料
===============================================================================

1.async同步函数await实例，实现接口前后相互依赖

   console.log('start');
   //获取第一个res
   axios.get(api.test1()).then(res=>{
     console.log("=======1======");
     console.log(res.data);
     console.log("=======1======");
   });
   //获取第二个res
   axios.get(api.test2()).then(res=>{
     console.log("=======2======");
     console.log(res.data);
     console.log("=======2======");
   });
    console.log('end');
    
    //采用这种结构，就行
    async function foo(){
      let x = await axios.get(api.test1());  //这个变成了同步代码
      let y = await axios.get(api.test2());  //这个变成了同步代码
      console.log(y.data);  
      console.log(x.data);
      console.log('333');
    };
    foo();




2.采用promise实现接口前后依赖效果
  new Promise(function(resolve,reject){
      axios.get(api.test1()).then(res=>{
        resolve(res.data);
      });
   }).then(myData=>{
       axios.get(api.test2()).then(res=>{
        console.log(myData); 
        console.log(res.data);
      });
   });






3.去除字符串空格方法
  <div id="app">
	<el-input v-model.trim="name" placeholder="请输入内容"></el-input>
	{{name}}-----{{myName}}
  </div>
  <script type="text/javascript">
	var app = new Vue({
		el:'#app',
		data:{
			name:'11111',
		},
		methods:{

		},
		computed:{
			myName(){
				let str = this.name.replace(/\s*/g,"")
				this.name = str;
				return str;
			},
		},
	});
  </script>






4.组件传值：
======================================================

（1）、父组件可以使用 props 把数据传给子组件。
（2）、子组件可以使用 $emit 触发父组件的自定义事件。

vm.$emit( event, arg ) //触发当前实例上的事件

vm.$on( event, fn );//监听event事件后运行 fn； 




4.文件上传
=====================================================
uploadFile(file){
      if(file.size>5*1024*1024){
        this.openError('文件大小不得超过5M！');
        return;
      };
      let fileData = new FormData();
      fileData.append("attFile",file.raw);
      api.CustomerQualificationGetInit().then(res=>{
        const params = { 
          bizId:res.result.form.customerQualificationId, //拿到上传附件的id
          attBizCode:'QualificationBiz001',
          attTypeCode:'QualificationType001', 
          attFile:fileData
        };
        api.FileUpLoad(params).then(res=>{
          if(res.result.length != 0){
            this.openSuccess('证照上传成功');
            this.ruleFormCompany.attId2 = res.result[0]; //需要一个变量来接收返回的id结果
            file.attchmentId  = res.result[0]; //给file添加属性attchmentId
            file.href = '/api/Attachment/Download/'+ res.result[0] + '?t='+ localStorage.access_token; //给file添加属性href
          }
          else{
            this.openError('上传失败');
          }
        });
      });
    },

// 销售中心 -> 新增项目 -> 上传附件-
upLoadFileCreate: async (params) => {
  const response = await Http.post(urls.baseUrl + '/Attachment/' + params.bizId + '?attBizCode=' + params.attBizCode + '&attTypeCode=' + params.attTypeCode , params.formdata,{
    headers: {
      "Content-Type": "application/x-www-form-urlencoded"
    }
  })
  return await response.data
 },
// 销售中心 -> 新增项目 -> 删除附件
upLoadFileDelete: async (params) => {
  const response = await Http.post(urls.baseUrl + '/Attachment/Delete/' + params.attachmentId,)
  return await response.data
 },


5.computed和watch的区别：
===================================================================================================================================
computed监听的变量是要重新命名的，不能用data里面的注册过的变量名。而且需要return值。相当于帅选好数据后就return给新的这个变量。
watch监听的变量是直接监听data里面已经注册过的变量名称。无需重新取名字。当有变化的时候，会触动你想要调用的方法，并且可以得到新值和旧值。


作用机制上
1.watch和computed都是以Vue的依赖追踪机制为基础的，它们都试图处理这样一件事情：当某一个数据（称它为依赖数据）发生变化的时候，所有依赖这个数据的“相关”数据“自动”发生变化，也就是自动调用相关的函数去实现数据的变动。
2.对methods:methods里面是用来定义函数的，很显然，它需要手动调用才能执行。而不像watch和computed那样，“自动执行”预先定义的函数
 【总结】：methods里面定义的函数，是需要主动调用的，而和watch和computed相关的函数，会自动调用,完成我们希望完成的作用

1.watch擅长处理的场景：一个数据影响多个数据
2.computed擅长处理的场景：一个数据受多个数据影响

watch: {
  firstName: function (val) { this.fullName = val + this.lastName }
}

computed:{
  fullName: function () { return this.firstName + lastName }
}



6.js的this指向问题
======================================================================
this的指向在函数定义的时候是确定不了的，只有函数执行的时候才能确定this到底指向谁，实际上this的最终指向的是那个调用它的对象

例一：this指向他最近的上一级window
function a(){
    var user = "追梦子";
    console.log(this.user); //undefined
    console.log(this);　　//Window
}
window.a();


例二：this指向他最近的上一级o
var o = {
    user:"追梦子",
    fn:function(){
        console.log(this.user);  //追梦子
    }
}
o.fn();

例三：this指向他最近的上一级o
var o = {
    user:"追梦子",
    fn:function(){
        console.log(this.user); //追梦子
    }
}
window.o.fn();

例四：this指向他最近的上一级b
var o = {
    a:10,
    b:{
        a:12,
        fn:function(){
            console.log(this.a); //12
        }
    }
}
o.b.fn();

例五：this指向他最近的上一级b
var o = {
    a:10,
    b:{
        // a:12,
        fn:function(){
            console.log(this.a); //undefined
        }
    }
}
o.b.fn();

例六：this指向他最近的上一级b
var o = {
    a:10,
    b:{
        a:12,
        fn:function(){
            console.log(this.a); //undefined
            console.log(this); //window
        }
    }
}
var j = o.b.fn;
j();
这里this指向的是window，是不是有些蒙了？
虽然函数fn是被对象b所引用，但是在将fn赋值给变量j的时候并没有执行所以最终指向的是window

总结：谁调用函数，那么this就指向这个谁。也可以理解为 指向函数的上一级。

          比如1：
             var age = 100;
             function aaa(){ 
                        console.log(this.age)   //输出100
             };
            aaa();   //等价于 window.aaa() ,  是window调用了函数，所以这里的this指向的是window

          比如2：
             var age = 200;
             var obj = {
                    age : 300,
                    bbb(){ console.log( this.age ) },  //输出300
                 };    
            obj.bbb();    //等价于 window.obj.bbb()  , 指向函数的上一级obj


Vue校验是否数字
===================================================================
<el-input v-model="ruleForm.assets" type="number" @keydown.native="checkInputNumber($event)" :placeholder="placeholder" oninput="if(value.length > 30) value = value.slice(0,30)"></el-input>
解释：
type="number" : 表示只能输入数字
oninput="if(value.length > 30) value = value.slice(0,30)" ：表示限制输入字符的长度
@keydown.native="checkInputNumber($event)"：表示每次键入触发的事件
 //只能输入数字
 checkInputNumber(e){
    let arr= ["-", "e", "+", "E"];
    if(arr.includes(e.key)){
      e.preventDefault(); //阻止默认输入字符
    };
    e.target.value = (e.target.value.match(/^\d*(\.?\d{0,1})/g)[0]) || null;   //保留小数点后两位
  },



Vue校验是否手机号码、电子邮件
===================================================================
<el-input @blur="telNoEvent"  v-model="ruleForm2.Mobile" maxlength="11" placeholder="请输入手机号码" show-word-limit size="small" style="width:280px;"></el-input>
<el-input @blur="postNoEvent"  v-model="ruleForm2.Email" maxlength="50" placeholder="请输入电子邮箱"  show-word-limit size="small" style="width:280px;"></el-input>


//手机号码输入框事件
    telNoEvent(){
      if(this.ruleForm2.Mobile.length > 0){
        if(!this.isPoneAvailable(this.ruleForm2.Mobile)){
          this.$message({message:'手机号码格式错误',type:'error' });
          return;
        };
      }
    },
    //电子邮件输入框事件
    postNoEvent(){
      if(this.ruleForm2.Email.length > 0){
        if(!this.isEmail(this.ruleForm2.Email)){
          this.$message({message:'邮箱格式错误',type:'error'});
          return;
        };
      }
    },
    //检测是否为手机号格式
    isPoneAvailable(poneInput) {
      var myreg=/^[1][3,4,5,7,8][0-9]{9}$/;
      if (!myreg.test(poneInput)) {
          return false;
      } else {
          return true;
      }
    },
    //检测是否为邮箱格式
    isEmail(mail) {
      var filter = /^([a-zA-Z0-9_\.\-])+\@(([a-zA-Z0-9\-])+\.)+([a-zA-Z0-9]{2,4})+$/;
      if (filter.test(mail)) {
          return true; 
      } else {
          return false;
      }; 
    },




var a = '';
var b = undefined;
var c = null;
var d = 0;
var e = false;
var f = true;
=======================================================

第一：var a = '',当a为空字符的时候
                 等价于false
                 等价于if(!a){alert('不存在')}
                 等价于0


第二：var b = undefined，当b为undefined的时候
                         等价于null
                         等价于if(!b){alert('不存在')};


第二：var c = null, 当c为null的时候
                    等价于if(!c){alert('不存在')};     




数组
=======================================================
快速入门——数组

Array.length; 获取长度 ?Array.length=X 可以直接改变长度


indexOf 返回指定元素位置


slice?slice(x,y) 返回x到y的一个数组，截取Array部分元素，返回新Array(不改变原数组) slice()复制整个数组


push() 尾末添加元素?


pop()?尾末删除元素


unshift()?头部添加元素?


shift()?头部删除元素


sort() 对Array进行排序，修改当前Array位置（默认顺序排序）


reverse() 把整个Array元素反转

splice() 改变原数组，删除，插入，替换 (x,y,z) 索引 执行几个 替换元素


concat() 合并两个数组，返回新数组(不改变原数组)


join() 数组转换成字符串join("") 指定符号拼接join("-")





只能输入数字-小数点后两位
======================================================================
<input type="text" v-model="telephone" @input="change(telephone,'telephone')">

data:{
     telephone: ""
   },
   methods: {

      change(val,params) {
        val = val.replace(/(^\s*)|(\s*$)/g, "")
        if(!val) {
          this[params] = "";
          return
        };
        var reg = /[^\d.]/g
        val = val.replace(reg, "")     // 只能是数字和小数点，不能是其他输入
        val = val.replace(/^\./g, ""); // 保证第一位只能是数字，不能是点
        val = val.replace(".", "$#$").replace(/\./g, "").replace("$#$", "."); // 小数点只能出现1次
        val = val.replace(/^(\-)*(\d+)\.(\d\d).*$/, '$1$2.$3'); // 小数点后面保留2位
        this[params] = val;
      },

   },


例子：=============
<div id="app">
   <br>
   电话号码：<input type="text" v-model="telephone" @input="change(telephone,'telephone')">
   <br>
   金额：<input type="text" v-model="money" @input="change(money,'money')">
</div>
<script>
var app = new Vue({
   el:'#app',
   data:{
     telephone: "",
     money:'',
   },
   methods: {
      change(val,params) {
        val = val.replace(/(^\s*)|(\s*$)/g, "")
        if(!val) {
          this[params] = "";
          return
        };
        var reg = /[^\d.]/g
        val = val.replace(reg, "")     // 只能是数字和小数点，不能是其他输入
        val = val.replace(/^\./g, ""); // 保证第一位只能是数字，不能是点
        val = val.replace(".", "$#$").replace(/\./g, "").replace("$#$", "."); // 小数点只能出现1次
        val = val.replace(/^(\-)*(\d+)\.(\d\d).*$/, '$1$2.$3'); // 小数点后面保留2位
        this[params] = val;
      },
   },
});
</script>


vue校验数字-小数-负数:正则表达式
===============================================================================================
<div id="app">
   <h1>电话号码：<input type="text" v-model="telephone" @input="onlyNumber('telephone')"></h1>
   <h1>邮编号码：<el-input type="text" v-model="postnumber" @input="onlyNumber('postnumber')"></el-input></h1>
   <h1>买入金额：<input type="text" v-model="buy" @input="onlyFloatNumber('buy')"></h1>
   <h1>欠债金额：<el-input type="text" v-model="total" @input="onlyNegativeNumber('total')"></el-input></h1>
   {{total}}
</div>
<script>
var app = new Vue({
   el:'#app',
   data:{
     telephone: "",
     postnumber:'',
     buy:'',
     total:'',
   },
   methods: {
     //只能输入正整数
     onlyNumber(arg){
       this[arg] = this[arg].replace(/[^\.\d]/g,''); //只能输入数字和点
       this[arg] = this[arg].replace('.','');        //禁止输入小数点
     },
     //可以输入小数点并保留几位小数
     onlyFloatNumber(arg){
       this[arg] = this[arg].replace(/[^\.\d]/g,''); //只能输入数字和点
       this[arg] = this[arg].replace(/^\./g, "");    //保证第一位只能是数字，不能是点
       this[arg] = this[arg].replace(".","$#$").replace(/\./g,"").replace("$#$","."); //小数点只能出现1次
       this[arg] = this[arg].replace(/^(\-)*(\d+)\.(\d\d).*$/,'$1$2.$3'); //保留小数点后面2位,\d\d\d表示保留3位
     },
     //只能输入正负整数
     onlyNegativeNumber(arg){
       var value = this[arg].charAt(0); 
       this[arg] = this[arg].replace(/[^\.\d]/g,''); //只能输入数字和点
       this[arg] = this[arg].replace('.','');        //禁止输入小数点
       if(value == '-'){
         this[arg] = '-' + this[arg];
       };
     },




   },
});
</script>

//最新的数字输入判断
==================================================================

<el-input @input.native="onlyFloatNumber($event)" maxlength="30" v-model="ruleForm.total" placeholder="请输入"></el-input>
<el-input @input.native="onlyFloatNumber($event)" maxlength="20" v-model="ruleForm.badMoney" placeholder="请输入"></el-input>
         
//金额正则
    onlyFloatNumber(e){
      e.target.value = e.target.value.replace(/[^\.\d]/g,''); 
      e.target.value = e.target.value.replace(/^\./g, "");   
      e.target.value = e.target.value.replace(".","$#$").replace(/\./g,"").replace("$#$","."); 
      e.target.value = e.target.value.replace(/^(\-)*(\d+)\.(\d\d).*$/,'$1$2.$3'); 
    },



  //只能输入正整数,同时不能输入小数点
    onlyNumber(e){
      e.target.value = e.target.value.replace(/[^\.\d]/g,''); 
      e.target.value = e.target.value.replace(/^\./g, "");   
      e.target.value = e.target.value.replace(".","$#$").replace(/\./g,"").replace("$#$",""); 
    },


















路由守卫 ：参考：https://www.cnblogs.com/zjh-study/p/10647220.html
======================================================================================
一、全局路由守卫
所谓全局路由守卫，就是小区大门，整个小区就这一个大门，你想要进入其中任何一个房子，都需要经过这个大门的检查
全局路由守卫有个两个：一个是全局前置守卫，一个是全局后置守卫

router.beforeEach((to, from, next) => {
    console.log(to) => // 到哪个页面去？
    console.log(from) => // 从哪个页面来？
    next() => // 一个回调函数
}
router.afterEach（to，from） = {}
next()：回调函数参数配置

next(false): 中断当前的导航。如果浏览器的 URL 改变了 (可能是用户手动或者浏览器后退按钮)，那么 URL 地址会重置到 from 路由对应的地址
next('/') 或者 next({ path: '/' }): 跳转到一个不同的地址。当前的导航被中断，然后进行一个新的导航。你可以向 next 传递任意位置对象，且允许设置诸如 replace: true、name: 'home' 之类的选项以及任何用在 router-link 的 to prop 或 router.push 中的选项




二、组件路由守卫
// 跟methods: {}等同级别书写，组件路由守卫是写在每个单独的vue文件里面的路由守卫
beforeRouteEnter (to, from, next) {
    // 注意，在路由进入之前，组件实例还未渲染，所以无法获取this实例，只能通过vm来访问组件实例
    next(vm => {})
}
beforeRouteUpdate (to, from, next) {
    // 同一页面，刷新不同数据时调用，
}
beforeRouteLeave (to, from, next) {
    // 离开当前路由页面时调用
}
实例：
<script>
    export default {
        data(){
            return{
                num : 10
            }
        },
        beforeRouteEnter:(to,from,next)=>{
            next(vm=>{
                alert(vm.num)
            })
        },
?
    }
</script>






三、路由独享守卫
路由独享守卫是在路由配置页面单独给路由配置的一个守卫

export default new VueRouter({
    routes: [
        {
            path: '/',
            name: 'home',
            component: 'Home',
            beforeEnter: (to, from, next) => {
               // ...
            }
        }
    ]
})






四、vue 数据变了，但是视图没有改变：可以用以下方法， https://segmentfault.com/q/1010000018899255/
====================================================================

方法一：
this.$set(this.form, 'name', '')
语法：this.#set(obj, key, value)        //key要加引号

例如：
list:[
       {name:'中智',age:22},
       {name:'港汇',age:33},
       {name:'徐汇',age:22},
     ],
this.list.forEach(item=>{
        
        this.$set(item,'valueNum',4);  //item.valueNum  = 4; 等价于，就是采用set的方式给list数组添加一个valueNum字段。

      });



方法二：
只能改变整个form才能避免这种情况 this.form=Object.assign({name:'张三'},this.form)

//先在data注册test
test:{
     title:'1111',
 },

//再方法里面：
let obj = {
          title: this.test.title,
          id : result.results[0].insureId
        };
this.test = Object.assign({}, obj);

或者：
this.test.id = '22222';
this.test = Object.assign({} ,  this.test );

这样就能触动视图的更新了








五、map方法到底会不会改变原始数组？ https://blog.csdn.net/weixin_33826268/article/details/91444116
=================================================================.

 map不不能遍历对象，只能遍历数组

“map()不会改变原始数组”这句话并不严谨。而应该是“当数组中元素是值类型，map不会改变原数组；当是引用类型，则可以改变原数组”。 


  然而，map方法体现的是数据不可变的思想。该思想认为所有的数据都是不能改变的，只能通过生成新的数据来达到修改的目的，因此直接对数组元素或对象属性进行操作的行为都是不可取的。





六。.Object.assign()基本用法： 把两个对象，或者一个对象一个数组进行合并，最终得到一个新的对象，     这种方法能触动视图的更新哦
===============================================================

assign其实就是深拷贝对象或者数组的意思，(只能一级属性的深拷贝，不能多层级的深拷贝)

assign的作用是：

公式：
Object.assign('最终得到的对象','对象A','对象B....')


第一：深拷贝，也就是复制对象/或者复制数组

let a = {name:'中智集团'};
let b = {age:'45岁'};
let c = {name:'北京长城',address:'香港铜锣湾'};
let d =  Object.assign({},a);

console.log(d);     //{name:'中智集团'}


第二：合并对象，(但是不能合并数组)
let f = Object.assign({},a,b);
console.log(f);                //输出{name:'中智集团',age:'45岁'}


第三：后面的属性会覆盖前面的属性，在合并的时候
let g = Object.assign({},a,b,c);
console.log(g);                //输出{name: "北京长城", age: "45岁", address: "香港铜锣湾"}


第四：实例，把一个对象和一个数组合并成一个对象，

     let arr = [{p:'小花',t:'小兔'},{r:'小羽',s:'小田'}];
     let obj = {c:'小猫',d:'小狗'};
     let x = Object.assign({}, arr , obj );            
     console.log(x);                          输出//{0: {p:'小花',t:'小兔'}, 1: {r:'小羽',s:'小田'}, c: "小猫", d: "小狗"}

第五：把对象或者数组合并到this里面去，//************这一点非常重要***********************************************************
     let arr = [1,2,5,7];
     let obj = {name:'中智', age:'33岁'}
     Object.assign(this, { arr , obj });
     console.log(this);
    公式：就是把记得要用大括号{ }把他们括起来，才能复制到this里面去哦。


总结：assign就是深拷贝的作用，可以深拷贝对象或者数组，但是不能拷贝常数或者字符串，不能拷贝二维数组




但是，我们十多年前就住的远也是改变不了的事实，我们不是说甩锅，让你爸去挣这个，而是文章叔说，实在是看不惯你爸总是被他们欺负打压，我们大家在后面尽量出一点力气和方案支援一下，
我们可能抓住重阳宝这个痛点，看看有机会弄一下他。你说了这么多，也对，可能帮倒忙了。那就当我没说！村里那班人确实坏，也怪大家不能统一到一起，任其摆布！








七、Collapse 折叠面板 用来替代   <el-tabs> https://www.cnblogs.com/grt322/p/8577862.html
================================================================
<el-collapse v-model="activeNames" @change="handleChange">
 2   <el-collapse-item title="一致性 Consistency" name="




八、怎么传有两层结构以上的参数对象呢？
==================================================================

   <h1>电话号码：<input type="text" v-model="telephone.tel" @input="onlyNumber('result.sum')"></h1>
   <h1>电子邮件：<input type="text" v-model="telephone.tel" @input="onlyNumber('result.email.num')"></h1>
   <h2>{{result.sum}}</h2>
   <h2>{{result.email.num}}</h2>

data:{
     telephone:{ 
        tel : '',
     },
     result:{
       sum: 1,
       email: {
         num:'3'
       }
     },
   },

onlyNumber(arg){
       let str = arg.split('.');
       let res = this;
       for(let i=0;i<str.length -1;i++){
         res = res[str[i]];                          // 先拿到除了最后一级的结果 this['result']  
       };
       res[str[str.length -1]] = this.telephone.tel; //再拿到最后一层级 this['result']['sum']
     
       // eval(`this.${arg} = ${ this.telephone.tel }`);  //这种方式是最快的
       // eval(`this.${arg} = ${ 1000 }`);                //这种方式是最快的

     },



九、new Map()的使用:  即创建一个Map对象实例，返回的结果是一个对象
====================================================================================================
主要作用是：它如同一个容器，用来装你需要的数据。然后提供了很多的方法来处理你的数据。

1.new一个map对象 ，键值唯一。           

例如：
var m = new Map();       //新建一个空的键值对对象，键值自动只能保存唯一的键值对，相同则后面的覆盖前面的。   

操作方法：
m.set("name","刘德华")   //给集合设置键值对
m.get("name")            //读取
m.has("name")：          //判断是否存在该键。如果值在集合中存在，返回true,否则false
m.delete(value)：          //从集合中移除一个值，并且会返回true或者false
m.clear():                 //移除集合里所有的项

遍历方法：
m.keys()：    返回一个包含集合中所有键的对象集合
m.values()：  返回一个包含集合中所有值的对象集合
m.forEach()： 用于对集合成员执行变量循环，没有返回值 
m.size：      返回一个包含集合中所有键值对的数量或者长度

去重
let links = [
  {id:'001',name:'刘德华'},
  {id:'002',name:'黎明'},
  {id:'002',name:'郭富城'},
  {id:'003',name:'周杰伦'},
  {id:'003',name:'张学友'},
];
//new一个map对象实例{},map的对象不会出现重复值
let res = new Map();
//帅选数据
links.forEach((item)=>{
	if(!res.has(item.id)){
		res.set(item.id,item); //利用map的has和set方法去重
	};
});
console.log(res);
let kong = [];
//利用map的forEach方法遍历map对象res
res.forEach(item=>{
	kong.push(item);
});

console.log(kong);










10，数组的 filter() 方法，返回的结果是一个新创建的数组， 只要不符合条件的数据，就不返回，那么新数组的长度就一定是小于或等于原数组的长度啦。
====================================================================================================
filter() 
         方法创建一个新的数组，新数组中的元素 是 符合条件的所有元素。
         帅选出来的数据或者返回回来的数据一定是“源数据”里面的数据，而且是“一模一样”的。*******比较重要，相当于是源数据的子集,不能改变返回的源数据，跟return没有关系了。
         只要不符合条件的就不返回，
         filter不会修改原数组，也不会修改新数组
         那么返回的新数组的长度，一定是小于或者等于 原数组的长度了。
         只需要“执行条件”，可以省去return， 当有表达式的时候，需要()括号包住
         只需要“执行条件”
         只需要“执行条件”即可，不需要别的。

         let arr = [
                     {id:1,name:'刘德华'},
                     {id:2,name:'郭富城'},
                     {id:3,name:'周杰伦'},
                   ];

         例子1：
         let roo = arr.filter(item => item.id == 3 );           //[{id:3,name:'周杰伦'}]
         等价于：
         let roo = arr.filter(item => ( item.id == 3 ) );       //[{id:3,name:'周杰伦'}]
         等价于：
         let roo = arr.filter(item => { if(item.id == 3){ return item } } );  //[{id:3,name:'周杰伦'}]


         例子2：
         let doo = [3,4,6,8];
         
         let roo = foo.filter(item => item * 2);  //结果还是： [3,4,6,8] 

         let roo = foo.filter(item => { return item * 3 }); //结果还是： [3,4,6,8] 
 
         总结：filter仅仅是用来筛选数据的，不能用来修改数据。不能对源数据进行加减乘除类似的运算。


         


         


11，数组的 map()方法，返回的结果是一个新创建的数组， 不管条件符不符合，都 一 一 返回，哪怕是undefined，那么新数组的长度一定是和原数组的长度相等哦
=====================================================================================================
map()   创建一个新的数组
        帅选出来的数据可以是改变了的数据(例如可以被加减乘除等等)
        不管条件符不符合，都一一返回，哪怕是返回undefined，一一映射哦
        那么新数组的长度一定是和原数组的长度相等哦 

      
2         4
3         5
5   +2    7
7         9
9         11

以上就表示映射，一一对应


例如：

let foo = [2,3,4,5,8];

let roo = foo.map(item => { return item * 2 });    //结果： [4,6,7,10,16];

等价于：

let roo = foo.map(item => item * 2);  //结果： [4,6,7,10,16];

等价于：

let roo = foo.map(item => (item * 4));



实例2：

let roo = foo.map(item => { if(item > 3){ return item } });    // 结果：[undefined, undefined, 4, 5, 8]  

总结：map方法，即使没有符合条件的项，他也会返回undefined，会一一映射，新数组的长度一定和原数组的长度是相等的，并且源数据可以被修改。进行加减乘除类似的运算。


例子3：
let arr = [
  {id:1,name:'刘德华'},
  {id:2,name:'郭富城'},
  {id:3,name:'周杰伦'},
];

let roo = arr.map(item => { if(item.id > 1){ return item.flag = 10 } }  ); 


console.log("roo",roo);
//结果：
0: {id: 1, name: "刘德华"}
1: {id: 2, name: "郭富城", flag: 10}
2: {id: 3, name: "周杰伦", flag: 10}

console.log("arr",arr);
//结果：
0: {id: 1, name: "刘德华"}
1: {id: 2, name: "郭富城", flag: 10}
2: {id: 3, name: "周杰伦", flag: 10}


总结：当源数据是引用类型的数据（对象型的数据）时候，源数据可以被修改。  当源数据是常量数字数组的时候，不会被修改。
          ******即：数组成员项是基本类型的时候，就不能修改原数组。 当数组成员项是引用类型的时候，就可以修改原数组了。

例如：

let arr = [2,3,4,5];
let brr = arr.map( item => { item = item * 2 ; return item; } );
console.log('arr',arr) ;
console.log('arr',brr) ;

let arr = [{num:2},{num:3},{num:4},{num:5}];
let brr = arr.map( item => { item.num = item.num * 2 ; return item } );
console.log('arr',arr) ;
console.log('brr',brr) ;






闭包：排列组合，用法一
================================================================
<script type="text/javascript">

//思路：
var index  = 0;
var source = ["a","b","c","d"];
var result = []; //最终的组合数据
function BiBao(){

  //第一步
  var kong = [];                  //每次先清空
      kong.push(source[index]);   //每次只会有一个项添加进去

  //第二步：开始拼接组合
  for(var c=0;c<result.length;c++){
     kong.push( result[c] + source[index] );
  };
  
  //第三步：合并两个数组，每次把kong数组里面的值有序添加到group数组中去
  for(var d=0; d<kong.length; d++){
  	result.push(kong[d]);
  };

  //每次累加
    index++;

  //第四部：判断是否终止闭包
  if(index < source.length){
  	BiBao(); //在这里无限循环，只要这里没有执行完，就不会执行下面的return
  };
  //当条件不满足之后，才来执行return，只会执行一次。
  return result;
};

var u = BiBao();
console.log("u",u);

</script>



闭包：排列组合，用法二：封装成函数
================================================================

<script type="text/javascript">

var source = ["a","b","c","d"];

function BiBao(source , index=0 ,result = []){
  //第一步
  var kong = [];                  //每次先清空
      kong.push(source[index]);   //每次只会有一个项添加进去
  //第二步：开始拼接组合
  for(var c=0;c<result.length;c++){
     kong.push( result[c] + source[index] );
  };
  //第三步：合并两个数组，每次把kong数组里面的值有序添加到group数组中去
  for(var d=0; d<kong.length; d++){
  	result.push(kong[d]);
  };
  //每次累加
    index++;
  //第四部：判断是否终止闭包
  if(index < source.length){
  	BiBao(source , index, result);  //在这里无限循环，只要这里没有执行完，就不会执行下面的return
  };
  //当条件不满足之后，最后才来执行return，跳出函数，只会执行一次。
  return result;
};

var res = BiBao(source);

console.log("res",res);

</script>




           逻辑或与非 ：作用，是用来取值的，是用来取值的，是用来取值的，要么取前面的，要么取后面的
=====================================================================

1、JS中的||符号：

   只要“||”前面为false,不管“||”后面是true还是false，都返回“||”后面的值。
   只要“||”前面为true, 不管“||”后面是true还是false，都返回“||”前面的值。

   === 总结：真前假后 ===

<script type="text/javascript">
var a = [1,2,3];
var b = "hello"; 
var obj = new Object(); 
var d;console.log(true || 10);//第一个操作数是true，结果是第一个操作，也就是true
console.log(false || b);//第一个操作数是false，结果是第二个操作数b
console.log(100 || false);//第一个操作数是100，结果100
console.log(undefined || 9);//第一个操作数是undefined转false，结果9
console.log(NaN || false);//第一个操作数是NaN转false，结果第二个操作数
console.log(null || a);//第一个操作数是null转false，结果a
console.log('' || false);//第一个操作数是空串转false，结果第二操作数
console.log(0 || 100);//结果是100
console.log(5 || 100);//5
console.log(a || b);//a
console.log(obj || 200);//obj
</script>


2、JS中的&&符号：

只要“&&”前面是false，不管“&&”后面是true还是false，结果都将返“&&”前面的值;
只要“&&”前面是true， 不管“&&”后面是true还是false，结果都将返“&&”后面的值;

<script type="text/javascript">
var a = [1,2,3]; var b = "hello"; 
var obj = new Object(); 
var d;console.log(true && 10);//第一个操作数是true，结果是第二个操作，也就是10
console.log(false && b);//第一个操作数是false，结果flase
console.log(100 && false);//第一个操作数是100，结果flase
console.log(undefined && false);//第一个操作数是undefined，结果undefined
console.log(NaN && false);//第一个操作数是NaN，结果NaN
console.log(null && false);//第一个操作数是null，结果null
console.log('' && false);//第一个操作数是空串，结果空串
console.log(0 && 100);//结果是0
console.log(5 && 100);//100
console.log(a && b);//hello
console.log(obj && 200);//200
</script>






       三元表达式书写风格，三元作用：既能执行运算，也能取值。
=======================================================================================================

1.赋值变量：取值。 取值的意思就是它一定会取其中某一个值。
let a = 100;
let b = 103;
let s;
let c = a > b ? (
      s = a - b,
      s*100
	) : (
      s = b -a,
      s*200
	);   为什么会返回值呢？
console.log(c);    //输出结果：600


2.封装函数：执行运算
可以根据需要来调用自己想要的function来处理更多的事情。
代码如下:
function a(){
   do something
}
function b(){
    do something
}
flag ? a() : b();

3.三元表达式，既能执行运算，也能取值。
  例如：
let x = 10;
let y = 20;
let z = x == 100 ? ( x*111 ) : ( y*111 );
console.log(z);  //输出2220








  搜索功能
=======================================================================================================

<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta http-equiv="content-type" content="text/html;charset=utf-8">
    <title>搜索功能</title>
    <script src="https://cdn.bootcss.com/jquery/1.9.1/jquery.js"></script>
</head>
<body>

<input type="text"  class="searchInput">
<ul class="searchResult"><span></span></ul>

<script type="text/javascript">

//搜索开始
var flagSearch = true;  // 初始flag为true，用于非中文字符的输入
$('.searchInput').on('compositionstart', function (){ // 绑定compositionstart事件
    flagSearch = false;
});
$('.searchInput').on('compositionend', function (){  // 绑定compositionend事件
    flagSearch = true;
});
$('.searchInput').on('input', function (e){ // 绑定指定事件
    setTimeout(function(){ // 这里为了防止事件 的先后顺序出错，给一个延时
        if(flagSearch){
           search(e); //调用搜索
        };
    },0);
});
//开始搜索
function search(e){
	var options = [
	  {name:'北京',href:'www.a.com'},
	  {name:'中智',href:'www.a.com'},
	  {name:'中国',href:'www.a.com'},
	  {name:'中方',href:'www.a.com'},
	  {name:'中方几百',href:'www.a.com'},
	  {name:'上海',href:'www.a.com'},
	  {name:'百中汇',href:'www.a.com'},
	  {name:'乌鲁木齐',href:'www.a.com'},
	  {name:'乌干达',href:'www.a.com'},
	  {name:'乌小红',href:'www.a.com'},
	];
    var str = e.target.value; //输入值
    console.log(str);
    var arr = []; //提炼出中文
    for(var i=0;i<options.length;i++){
      arr.push(options[i].name);
    };
    var brr = []; //拆分中文
    for(var j=0;j<arr.length;j++){
      var letters = arr[j].split('');
      brr.push(letters);
    };
    console.log("brr",brr);
    var crr = []; //对拆分后的中文进行排列组合
    for(var a=0;a<brr.length;a++){
       crr.push(paiLieZuHe(brr[a], index=0, result=[]));
    };
    //排列组合 [a,b,c,d]
    function paiLieZuHe(source, index=0, result=[]){
      var kong = [];
          kong.push(source[index]); //kong里面永远只会仅有一个元素，长度为1
      for(var n=0;n<result.length;n++){
      	kong.push( result[n] + source[index] ); //每次只拿出一个和result组合拼接
      };
      for(var s=0;s<kong.length;s++){
      	result.push(kong[s]);   //组合完之后就push到result
      };
      index++;
      if(index < source.length){
      	paiLieZuHe(source , index , result);
      };
      return result;
    };
    console.log("crr",crr);
    //搜索中文-匹配中文
    var drr = [];
    for(var k=0;k<crr.length;k++){
      var flag = crr[k].indexOf(str);
      if(flag != -1){
      	drr.push(crr[k]);
      };
    };
    console.log("drr",drr);
    //提取最后一个中文词组
    var err = [];
    for(var q=0;q<drr.length;q++){
    	var len = drr[q].length;
        var obj = drr[q][len-1];
        err.push(obj);
    };
    console.log("err",err);
    //开始匹配原数组,去匹配链接
    var frr = []; 
    for(var f=0;f<err.length;f++){
      for(var m=0;m<options.length;m++){
        if(err[f] == options[m].name){
		  frr.push(options[m]);
		};
      };
    };
    console.log("frr",frr);
    //生成html
    var html = '';
    for(var p=0;p<frr.length;p++){
       html = html + '<li><a href="'+frr[p].href+'">'+frr[p].name+'</a></li>' + '\n';
    };
    $('.searchResult').empty(); //先清除被选元素的所有子节点
    $('.searchResult').append(html);  //再插入到html
};

		
	
</script>
</body>
</html>



  flex布局            //参考：https://www.jianshu.com/p/4290522e1560
=======================================================================================================

第一：任何一个容器都可以指定为Flex布局。

      .box{display:flex;}   

       行内元素也可以使用Flex布局。

      .box{display:inline-flex;}       //注意，设为Flex布局以后，子元素的float、clear和vertical-align属性将失效。
      
      让子元素垂直居中对齐,子元素均分父容器的空间
      .foo{
	display: inline-flex; align-items:center;
      }


二、基本概念

    采用Flex布局的元素，称为Flex容器（flex container），简称”容器”。
    它的所有子元素自动成为容器成员，称为Flex项目（flex item），简称”项目”。
    容器默认存在两根轴：水平的主轴（main axis）x , 和垂直的交叉轴（cross axis）y。


第三：容器(父元素)的4个属性     //其实有6个属性

      flex-direction

        子元素排列方向                      //.box{flex-direction: row|row-reverse|column|column-reverse;}  //行排，列排，及对应得翻转
      flex-wrap             子元素换行                          //.box{flex-wrap:nowrap|wrap|wrap-reverse;}
      justify-content       子元素在(x轴水平方向)的对齐方式    // .box{justify-content:flex-start|flex-end|center|space-between|space-around;}

      align-items

           子元素在(y轴垂直方向)的对齐方式    // .box{align-items:flex-start|flex-end|center|baseline|stretch;} 
      
      


第四：项目(子元素)的属性
       
      order         ：标记子元素的排列顺序。数值越小，排列越靠前，默认为0。

      flex-grow     ：定义宽度，按比例放大宽度，即扩展的意思

      flex-shrink   : 缩放宽度，按比例缩小宽度

      flex-basis    ：flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）

      flex          ：flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。

      align-self    ：align-self属性允许单个项目有与其他项目不一样的对齐方式


      
实例：
：让子元素垂直居中对齐,子元素均分父容器的空间

.foo{
	display: inline-flex; align-items:center; flex-direction:row;
}
.foo div{
  background: #eee;  border:#9ee 1px solid; 
}
.foo div.a{
	order:1;
    flex-grow: 1;
}
.foo div.b{
	order:2;
    flex-grow: 2;
}
.foo div.c{
	order:3;
    flex-grow:4;
}

总结用法：首先定义父元素容器flex，其次定义子元素，flex




  CSS content 属性用法 //字体图标       字体图标请参照：https://fontawesome.dashgame.com/      参考：https://www.cnblogs.com/lflj/p/6439837.html    
=======================================================================================================

  1.什么是伪元素（Pseudo element）？

  答：伪元素不是真正的元素，不存在dom文档之中，所以js无法操作他。
      不存在文档树当中，
      那为什么叫他“元素”？因为我们可以对其进行跟元素几乎无差别的css样式操作。


  2.伪元素有哪些？

    before,after,first-letter,first-line,link,hover,active,visited 等等

  3.怎样表示伪元素?
   
    可以使用双冒号，也可以使用单冒号  // a:after{},  a:hover , a::before ,a::visited . 建议使用双冒号。
 
  4.before与after的用法总结:

    before定位的基准是其主元素的开始处，
    after定位的基准是主元素的结尾处。
    
    这两者是行样式，

    这两者必须配合content使用，内容为空的时候用‘’表示。
    content是伪元素必需的属性

    当主元素没有内容时before与after仍会正常工作，属性为inline元素，
    若需要设置高宽度等属性需要display：block;。


  5.实例

    <div id="app">
      <a href="http://www.runoob.com">中智上海</a>
    </div>
    
    #app a{ color: #ff9900 }
    #app a:hover{ color:#000; }
    #app a::before{ content: "我加在了当前元素的前面怎么样啊>>"; border:1px #000 solid; display: inline-block; width: 140px; vertical-align: middle;   }
    #app a::after { content: "<<我加在了当前元素的后面";  }


   6.before与after的主要用途
     
     答：是对元素默认样式的的美化，也可以很好地解决垂直居中对齐的问题

      垂直居中

      #app a::before{ content: "我加在了当前元素的前面怎么样啊>>"; border:1px #000 solid; display: inline-block; width: 140px; vertical-align: middle; line-height: 25px; }
      #app a::after { content: "<<我加在了当前元素的后面";  border:1px green solid;display: inline-block;vertical-align: middle;  }




      如何用 es6+ 写出优雅的 js 代码                     参考地址：https://www.jianshu.com/p/255c08ecd533
============================================================================================================

  查看了js的手册后发现，在js中return 这个单词，只能放在function中，如果不是在一个function中弹出如上错误。 “SyntaxError: Illegal return statement”
  解决方法只要把这个if语句放到一个函数中即可。

  1.中断循环总结：
    for ：         可以用return，即中断了遍历，也终止了当前函数，跳出了当前的函数。不在执行之后的所有代码。 但是break，只会中断遍历，但是不会跳出函数体。
    forEach：  可以用return，只会中断一次遍历，即return之后的代码不会被执行，但是不会跳出当前函数，而函数里面的其他的代码会继续执行。另不能用break
    map：       可以用return，只会中断一次遍历，即return之后的代码不会被执行，但是不会跳出当前函数，而函数里面的其他的代码会继续执行。另不能用break
    filter：       可以用return，只会中断一次遍历，即return之后的代码不会被执行，但是不会跳出当前函数，而函数里面的其他的代码会继续执行。另不能用break





    
 2.解构赋值 批量声明变量
   // 传统的声明变量
       let age = 22
       let name = 'guodada'
       let sex = 1
   // 批量声明变量1，都放在数组里面
      ES6:
      let [age, name, sex] = [22, 'guodada', 1]
      console.log(age, name, sex) // 22, guodada, 1

   //批量声明2，都放在数组里面
     let [ name ,brr , obj ] = ['tom' , [2,5] , {a:'松江',b:'青浦'}];
     console.log(name,brr,obj);   

  //在对象中使用:
     const obj = {
                firstName: 'guo',
                lastName: 'dada'
        }
     let { firstName, lastName } = obj

  //使用在函数中:
   function f(x, y) {
       return {x: x, y: y};
    }
   f(1, 2)   // Object {x: 1, y: 2}


 3.
    let arr = [1, 2, 3, 4]   //
    Array.isArray(arr)     // true 判断是否为数组
    arr.includes(2)         // true 判断数组中是否包含某项
    arr.findIndex(d => d === 3)  // 2 找出第一个符合条件的数组成员并返回数组下标, 找不到返回 -1
    arr.find(d => d === 3)           // 3 找出第一个符合条件的数组成员并返回, 找不到返回 undefined



           javascript的堆栈原理
===========================================================================================
   
   1.（栈数据）基本类型数据： (值类型) ：不可改变的原始值：Number、String、Boolean、undefined、null
   2.（堆数据）引用类型数据： (引用值)  :  array、object、function

   什么是基本类型数据？
   答：简单的数据段。存放在栈内，占据固定大小的空间。例如：Number、String、Boolean、undefined、null

   什么是引用类型数据？
   答：指那些可能由多个值构成的对象，存放在堆内。例如：array、object、function

    啥是堆？啥是栈？
    答：堆是堆、栈是栈，没有单独的“堆栈”这种结构的数据。        
           1.所有申明的'变量名'都存放在栈（包括 基本类型、引用类型、函数），
           2.栈只存放基本类型数据的'值'，   
           3.栈还存放引用类型数据的'地址'，而不存放引用类型的真实值，引用类型的真实值被存放在堆内存，而栈里的地址指向堆的真实值。


   第一：详解栈数据结构
                       特点：1、5种基本类型数据的'值'都存放在栈内存，                                   //Number、String、Boolean、undefined、null
                                 2、栈数据是遵循次序。同名取值时，会被覆盖，是后进先出。        //增加和删除变量，要遵循次序。即若是变量名有相同，后进来的会覆盖前面的数据，类似羽毛球桶
                                 3、栈数据由编译器自动分配释放内存空间，                                    //程序执行完之后会自动释放。 存取速度很快。         
                                 4、栈数据的复制等价于深拷贝。(重点) 即直接复制了其'值'            //复制栈数据之后是“值”的传递，复制以后相互再无关联，修改其中一个不会影响另一个。
                     例如1：
                                 var str = "中智";      //定义栈数据
                                 var a = str;              //复制栈数据
                                 var str = "北京";      //修改栈数据
                                 console.log(a);           //输出：中智           
                                 console.log(str);         //输出：北京
                     例如2：
                                  var bool = true;     //定义栈数据
                                  var b = bool;         //复制栈数据
                                  var bool = false;   //修改栈数据
                                  console.log("bool",bool);   //输出：false
                                  console.log("b",b);              //输出：true

    第二：详解堆数据结构
                    特点： 1、3种引用类型数据的'值'都存放在堆内存。在栈中只保存其地址   //array、object、function
                               2、堆数据是不遵循次序。                                                               //堆就像一个仓库，随机存，直接取。可以随心所欲的进行增加变量和删除变量，不用遵循次序。
                               3、 一般由程序员分配、释放内存空间，                                         //执行完之后，不会自动释放。堆是在程序运行时才触发(申请空间)，而不是在程序编译时(申请空间)。
                               4、堆数据的复制等价于浅拷贝。(重点) 即复制的是其'地址'            //复制堆数据，仅仅只是复制了他的"值"的地址，相互之间有关联，修改其中一个也会影响另一个。

                    例如1：
                                  var arr = [2,4,7,8];            //创建一个堆数据
                                  var brr = arr;                   //复制一个堆对象
                                  arr[1] = 999;                  //改变堆内存里面的值
                                  console.log("arr",arr);   //输出：[2,999,7,8]
                                  console.log("brr",brr);   //输出：[2,999,7,8]

                    例如2：
                                 var obj = {name:'中智', age:'20岁'};                //创建一个堆数据，地址存在栈中，真实数据则存在堆中
                                 var happyObj = obj;                                       //复制一个堆对象
                                 obj.name = "上海";                                         //改变堆数据的结构 
                                  var happyObj = {sex:'男',height:'180cm'}    //重新定义一个堆对象，划分一个堆空间给他，在栈中保存的地址不在指向obj
                                  console.log("obj",obj);                                  //输出：{name:'上海', age:'20岁'}      
                                  console.log("happyObj",happyObj);            //输出：{sex:'男',height:'180cm'}   
                      例如3：
                                 var a = {n:1};
                                 var b = a;
                                 a = {n:2};
                                 console.log("a",a);     //输出：{n: 2}
                                 console.log("b",b);    //输出：{n: 1}
                        
           


        第三：函数存在哪里？

                 var str_a = "Hello World";
function fn_a(arg){
    console.log(arg); // #1 --> Hello World
    arg = "Hai";
    console.log(str_a,arg); // #2 --> Hello World , Hai
};
fn_a(str_a);



                      
          
                     

实例：
var str_a = "a"; // 为str_a分配栈内存:str_a:"a"
var str_b = str_a; // 原始类型直接访问值,so,为str_b新分配栈内存:str_b:"a"
str_b = "b"; // 栈内存中:str_b:"b"。str_b的值为"b",而str_a的值仍然是"a"

// 分隔 str 和 obj -----------------------------------------------------------//
var obj_a = {v:"a"}; // 为obj_a分配栈内存访问地址:obj_a,堆内存中存对象值:{v:"a"};
var obj_b = obj_a; // 为obj_b分配栈内存访问地址:obj_b,引用了堆内存的值{v:"a"}
obj_b.v = "b"; // 通过obj_b访问(修改)堆内存的变量,这时候堆内存中对象值为:{v:"b"},由于obj_a和obj_b引用的是堆内存中同一个对象值，所以这时候打印都是{v:"b"}
obj_b = {v:"c"}; // 因为改的是整个对象，这里会在堆内存中创建一个新的对象值:{v:"c"},而现在的obj_b引用的是这个对象，所以这里打印的obj_a依旧是{v:"b"},而obj_b是{v:"c"}(两者在内存中引用的是不同对象了)。

总结：栈是用来存放基本类型数据的值，和存放引用类型数据的地址的
           堆是用来存储引用类型的真实值，而栈内的地址就指向这个真实值。

    栈：所有在“方法中”定义的变量都是放在栈内存中，随着方法的执行结束，这个方法的内存栈也自然销毁。
    值类型是存在栈里的，存取速度都很快。
    栈的特点：先进后出，类似羽毛球桶，先放进去的羽毛球，要想拿出来，必须先把后放进去的羽毛球拿出来。
   引用类型的真实数据存在堆里。  堆的特点：堆就像一个仓库，随机存，直接取，没有像栈这么麻烦。
   栈(stack)会自动分配内存空间，会自动释放。堆(heap)动态分配的内存，大小不定也不会自动释放。
   为什么编程语言中需要堆和栈 ? 参考：    https://blog.csdn.net/u010632868/article/details/79465569 
   为什么既需要栈又需要堆   https://blog.csdn.net/u010632868/article/details/79465569


 


          computed和watch 怎么监听对象，怎么监听数组，深度监听
===========================================================================================


第一：watch监听整个对象:   handler + deep

data:{
      result:1,
      obj:{
        name:'tom',
        age:'22岁',
        sex:'男'
      },
      company:'中智'
    },
    
    watch: {
       //监听对象，固定格式：handler + deep
       //只要obj中的属性发生变化，便会执行handler函数
       obj: {
         handler(){
           this.result --;
         },
         deep:true,
       },
       //监听普通变量 
       company( newValue, oldValue ){
         this.result ++;
       },
    },

第一：watch监听整个数组:   handler + deep



第二：watch监听对象中的某个属性:   computed + watch

data:{
      result:1,
      obj:{
        name:'tom',
        age:'22岁',
        sex:'男'
      },
      company:'中智'
    },

    computed: {
      //先注册一个变量ageModel,来存放对象obj里面的age值；
      ageModel(){
        return this.obj.age;
      },
    },
    
    watch: {
       //再在通过watch来监听ageModel变量，
       //就达到了监听对象中的具体属性值的变化啦。牛逼
       ageModel(newValue, oldValue){
          this.result ++ ;
       },
    },


第三：computed的get和set用法：

     computed是用来进行数据双向绑定的。
     get方法是用来获取值得，展示值得，需要一个return值。
     set是用来触发函数的，就是让他去干活，让别人做事。

data:{
      result:1,
      fristName:'叶',
      lastName:'龙',
    },

    computed: {
      fullName:{
        get(){
          return this.fristName + this.lastName;
        },
        set( newValue ){
          this.result ++ ;
          this.fristName = 1;
          this.lastName = 2;
          console.log(newValue);
        }
      },
    },



第四：watch 和 computed的区别？

       1.计算属性computed相当于在data里面注册了一个新的属性
       2.计算属性computed是多对一，其他几个变量的变化可以汇聚给一个变量使用
       3.computed必须要配合return。
       4.watch是一对多，即可以监听data里面的某一个变量也可以监听computed里面的某一个变量，然后就可触动函数，让他干活
       5.watch 和 computed 与 methods没有关系，他们是平行的等级。
       6.methods下的数据，是每次都会进行计算的
       7.watch擅长处理的场景：一个数据影响多个数据 ，computed擅长处理的场景：一个数据受多个数据影响





        如何判断数组是否存在？
=============================================================================================
      答案：
     let arr = [];
     if( arr && arr.length ){ .....do something.......}
   


        如何判断他是数组还是对象呢？
=============================================================================================

第一种方法：    
       
        constructor这个隐性的属性

        答案：因为所有的js对象(包括数组，对象，函数这3个对象)都具有一个隐藏的属性，那就是constructor属性，他看不见但是实际又存在哦。
                   
        因typeof只能判断基本类型变量，不能判断出引用类型对象。所以可以利用constructor这个属性来判断是否是数组 哦。

        总结：引用类型的数据，都具有constructor这个隐性的属性哦。
                   
        let arr = [1,2];
        console.log('数组否',arr.constructor === Array);                 //true
        //或者
        console.log('数组否',arr.constructor.name === 'Array');     //true

        let objj = {name:'刘德',age:22}
        console.log(objj.constructor.name);    //Object

 第二种方法：
   
         答案：利用instanceof来判断。

         先说说 typeof 和 instanceof 的区别？

         两者都可以用来判断变量，
         而typeof会返回"基本类型"
         而instanceof只会返回一个"布尔值"

         let brr = [7,8,9];
         let flag = brr instanceof Array;
         console.log('flag',flag);                 //true

 第三种方法：

         答案：Array.isArray()方法

         let crr = [7,7,9]
         let flag = Array.isArray( crr );
         console.log('flag', flag );            //true







        什么是js原型，prototype,   (proto:原型) 原型; 雏形; 最初形态;

=============================================================================================

     我们知道原型是一个对象


      第一：原型与原型链的区别？
                 原型是指：prototype
                 原型链是指：__proto__
                 两者是独立分开的哦。。。。。。。。

       第二：谁具有原型？
                   只有函数才有prototype属性。
                   只有对象拥有__proto__。


      *注意：
       1. 注意，千万不要使用字面量方式来定义属性和方法，否则原有属性和方法会被重写：// 字面量定义方法，原型被重写，原有属性和方法被更新
       2. 通常使用构造器（函数体）定义属性，使用原型对象（prototype）定义方法。如此，构造器只包含属性定义，而方法则分装在不同的代码块，使代码更具可读性：

       原型的作用 ？？？
                /*原型的作用：数据共享
		 * 不需要共享的数据写在构造函数中，需要共享的数据写在原型中
		 * 
		 */
		
		
		function Strudent(name,age,sex){
			this.name=name;
			this.age=age;
			this.sex=sex;
		}
		//使用人身高都是188，所有人的体重是55
		
		//所有学生都每天写500行代码
		
		//所有学生每天吃一顿饭
		
		Strudent.prototype.height="111";
		Strudent.prototype.weight="55ke";
		Strudent.prototype.study=function(){
			console.log("ddd")
		};
		Strudent.prototype.eat=function(){
			console.log("3333");
		}
 





        什么是js原型链
=============================================================================================



        什么是js构造函数：
===========================================================   https://www.cnblogs.com/helena000/p/6501604.html   ==================================

   ** 构造函数里面 定义的 属性 或者 方法 尽量 最好加上 前缀 this，

   例如：function nba(){
                 this.name =  '麦迪';
                 this.say = function(){};
             };

如果这个班上有60个学生，我们得重复写60遍
function Person(name,age, sex,) {
    this.name = name;
    this.age = age;
    this.sex= sex;
}

通过构造函数来创建对象了。此时你会发现，创建对象会变得非常方便。
var p1 = new Person('zs', 5,'男');
var p2 = new Person('luci', 5,'女');
var p3 = new Person('jack', 6,'男');
var p4 = new Person('lusi', 6,'女');



  ** JS中构造函数和普通函数有什么区别 ？？？


 ** 构造函数有什么作用？

   答：生成对象并初始化，有点像自己封装一个方法，也有点像是自己创建了一个全新的对象/方法，里面有初始化的属性和方法可以调用。


　构造函数都应该以 一个大写字母开头，eg:

    任何函数，只要通过 new 操作符来调用，那它就可以作为构造函数 ；

　任何函数，如果不通过 new 操作符来调用，那它跟普通函数也没有什么两样。

　　demo:

　　//创建函数

　　function Person(name,age,job){

　　　　this.name = name;

　　　　this.age = age;

　　　　this.job = job;

　　　　this.sayName = function(){

　　　　　　alert(this.name);

　　　　}

　　}

　　//当做构造函数使用

　　var person = new Person('Nicholas',29,'Software Engineer');//this-->person      此时的this指向了person

　　person.sayName();//'Nicholas'

 

　　//当做普通函数调用

　　Person('Greg',27,''Doctor);//this-->window      此时的this 指向 window

　　window.sayName();//'Greg'





                什么是js原型
===================================================================================

答案：原型是构造函数，的一个特殊对象，只有函数才有原型对象。

原型的作用之一：共享数据，节省内存空间。

原型对象里面有：一个固定的construction，和一个固定__proto__(俗称隐示对象，它指向Object()的原型对象  , 因为是 Object() 生成的 prototype对象  )，还有若干你自己定义的方法或属性

**方法的调用原来是可以通过per.__proto__.eat()来调用，但是因为__proto__是给浏览器看的，并不是标准的，所以用per.eat()来调用。


每个对象(包括普通对象，或者实例对象，或者prototype对象)都有 __proto__ 属性，  但只有函数对象才有 prototype 属性

所有函数对象的proto都指向Function.prototype，它是一个空函数（Empty function）

所有对象的 __proto__ 都指向其构造器的 prototype    






     ////判断数据类型
============================================================================================
var a = 1;
var b = '姚明'
var c = { name:'tom' }
var d = function(){};
var e = [];
console.log(typeof a);
console.log(typeof b);
console.log(typeof c);
console.log(typeof d);
console.log(typeof e);

//都是大写的Array单词
console.log( Array.isArray(e) );
console.log( e instanceof Array );  //数组e是否是Array函数的实例？true
console.log( e.constructor === Array); //等价于console.log( e.__proto__.constructor === Array);







    

       Promise讲解
============================================================================================

  注意：创建一个Promise对象会立即执行里面的代码，所以为了更好的控制代码的运行时刻，可以将其包含在一个函数中，并将这个Promise作为函数的返回值。
 function greet(){
    var promise = new Promise(function(resolve,reject){
        var greet = "hello  world";
        resolve(greet);
    });
    return promise;
    }
    greet().then(v=>{
    console.log(v);//*
    })


//实例
//把异步的操作放在Promiss的执行器里面，then里面的代码一定会等到执行器里面的代码执行完之后，才会被执行。
执行器只会有两种结果，一个是成功的resolve，一个是失败的reject。

let p1 = new Promise(function(success , fail){

	axios.get('https://yesno.wtf/api').then(result => {

		console.log(result);

		if(result.data.answer == "yes"){
			success(result.data);
		}else{
			fail('对不起，找不到数据');
		};
	});

});

//链式反应
p1.then(res=>{

	console.log(res);

	return res.answer

}).then(ues =>{

	console.log( ues );
	
}).catch(error => {
	console.log("error:" + error);
});









        jQuery怎么访问函数中的内部变量
=============================================================================================
       答案：就是在函数外面定义一个全局的变量。

       例如：

程序开始
//这是查看大图片
     var imgIndex = undefined;   //再函数外面设置一个全局的变量          //设置当前被点击图片的是第几张图片

//开始点击每一张图片
$('.seePhoto ul li img').click(function(){
    var imgs  = $('.seePhoto ul li img');
    var self  = $(this)[0].src;
    var index = arr.indexOf(self);
    imgIndex = index; //赋值给全局变量
});

//上一张
$('.pre').click(function(){
    console.log( imgIndex  );   //在别的函数可以使用这个全局的变量，相当于间接的访问到了其他函数内部的值了。
});

//下一张
$('.next').click(function(){
    console.log( imgIndex  );   //在别的函数可以使用这个全局的变量相当于间接的访问到了其他函数内部的值了。
});
程序结束




        vueX 语法糖？   辅助函数 讲解    参考：https://vuex.vuejs.org/zh/guide/getters.html
                                                                       https://zhuanlan.zhihu.com/p/100941659
=============================================================================================

   mapState, mapGetters, mapActions, mapMutations
   这些名字呢，是对应四大金刚的一个辅助函数，

  如果这样写就不需要...
  computed:  mapState({  count: state => state.count });

 如果这样写就需要...
 computed: {
    username(){  return 100  },
    ...mapState({  'count: ' , 'age' , 'address'  });
},

一条重要的原则就是要记住 mutation 必须是同步函数。







        了解angular？
=============================================================================================




        Vue的机制和原理  Object.defineProperty                                                    参考：https://www.jianshu.com/p/c02cb881bea8        https://www.cnblogs.com/ranyonsue/p/9717685.html
          
===========================================================================================
       
      Object.defineProperty






          连续赋值与求值顺序 var a = b = 8
===========================================================================================

           参考：      https://www.cnblogs.com/huaan011/p/4381703.html
           参考：      https://blog.csdn.net/qq_34035425/article/details/83085564





          js运行机制 **************
===========================================================================================
  
第一：
   js的运行分为两块：1.第一块是：主线程运行，
                                  2.第二块是：事件队列运行，

   所有的同步代码和同步函数都被放在主线程的执行栈里面。
   所有的微任务和宏任务都被放在事件队列里面。

   两者之间的关系是： js首先运行主线程，只有当主线程的执行栈为空，即排队的代码全部被执行完之后的时候，
                                   主线程才会去调用事件队列表里面的微任务或者宏任务，先调用微任务，再调用宏任务，而且是不断循环的去检查事件队列表，直到为空。
          

  Event Loop（事件循环/或/任务队列）

第二：
     new Promise()是同步代码，会立即执行
     new Promise.then() 是异步代码

    参考：https://www.jianshu.com/p/e06e86ef2595








          false、0、null、undefined和空字符串( 五种基本类型数据之间的关系 )
===========================================================================================
         
let a = true;                  //console.log(Number(a))  转换结果：1     if(a) 执行true分支
let b = 0;                      //console.log(Number(b))  转换结果：0      if(b) 执行false分支
let c = '';                      //console.log(Number(c))  转换结果：0        if(c) 执行false分支
let d = null;                 //console.log(Number(d))  转换结果：0        if(d) 执行false分支
let e = undefined;      //console.log(Number(e))  转换结果：NaN   if(e) 执行false分支
let f = false;                //console.log(Number(f))   转换结果：0         if(f) 执行false分支

//第一类：
0 == '', '' == false , false == 0 ,  //结果：true

//第二类：
null == undefined  //结果：true

//第三类：以下结果全是：false
null == false ,   
null == 0,
null == '',
undefined == false , 
undefined == 0 ,   
undefined == '',

//总结：null和undefined可以互等，但是null和undefined不能和其他三个(0,false,'')互等，而这3个却可以互等。但是在使用if(a)语句的时候，null和undefined却可以转换为0


if(e){
  alert('真的');
}else{
  alert('假的');
};

结论：把0、空字符串和false归为一类，称为“假值”；把null和undefined归为一类，称为“空值”。
当你用==操作符将这个5个对象进行比较的时候，你会发现：
只有0、空字符串和false可以互相相等==，
而null和undefined和其他三个都不相等，
但null和undefined是相等的。



什么是常量？ let 与 const的不同点
================================================================

1.什么是常量？

常量就表示是一些固定不变的数据,。比如：出生是男生,那么就是男生,。女生就是女生,一辈子不会改变.

2.常量有哪些
   数字型常量
   布尔型常量
   字符串常量
   
   总结：基本类型数据就是常量




      js对日期加减指定天、时、分、秒                    例如：当前日期为 2016-12-11 20:20:20

            https://blog.csdn.net/qq395537505/article/details/78753237?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase
===========================================================================
var t = new Date();//你已知的时间
 var t_s = t.getTime();//转化为时间戳毫秒数

 
 t.setTime(t_s + 1000 * 60);//设置新时间比旧时间多一分钟
 alert(t) // 2016-12-11 20:21:20
 
 
t.setTime(t_s + 1000 * 60 * 60);//设置新时间比旧时间多一小时
 alert(t) // 2016-12-11 21:20:20
 

 t.setTime(t_s + 1000 * 60 * 60 * 24);//设置新时间比旧时间多一天
 alert(t) // 2016-12-12 20:20:20


var t = new Date();//你已知的时间
 
t.setTime(t.setMinutes(t.getMinutes() + 1));//设置新时间比旧时间多一分钟
alert(t) // 2016-12-11 20:21:20
 

t.setTime(t.setHours(t.getHours() + 1));//设置新时间比旧时间多一小时
alert(t) // 2016-12-11 21:20:20



//往前减去10天
let t = new Date();
      let nowTime = t.getTime();      //把日期格式转化为毫秒数的时间戳格式
      let newTime = nowTime - (1000 * 60 * 60 * 24)*10;  //设置新时间比旧时间少10天，转化成毫秒
      let end  = t.setTime( nowTime );  //把时间戳格式转化为日期格式
      let star = t.setTime( newTime );  //把时间戳格式转化为日期格式
      this.upLoadTime = [ star, end ];


//往前减去一个月
      let t = new Date();
      let nowT = t.getFullYear() + "-" + (t.getMonth() + 1);  //组装到了当前的年月
      let standard = new Date( nowT );                        //将当前的日期格式转换为(中国标准时间)
      let yue = standard.getMonth() - 1;                      //得到当前月，从标准时间里面提取月份，需要减去1一个月，
      let stamp = standard.setMonth( yue );                   //将日期转化成时间戳毫秒格式
      let r = new Date( stamp );                              //将时间戳转化成(中国标准时间)
      let newT = r.getFullYear() + "-" + (r.getMonth() + 1);  //最后再次组装时间
      this.upLoadTime = [ newT , nowT ]; 




     new Map()   总结：
=================================================================

   1.与new Array()的区别？
     答：new Map()是一个对象格式
            new Array()是一个数组格式

  2.特点？
     答：(1)键值对结构                          //在new Map 里面主要强调是"键"
            (2)键和值可以是任何数据类型 // { "true"=>"19", "name"=>"姚明", {age:"22"} => "88" , [2,3] => "99" }

  3.键名相同就覆盖
     答：如果同一Map对象中的两个"键名"相同，那么后面的这个键值对，会覆盖前面的那个键值对，即只要健名相同( 即严格相等 )就会覆盖。这样就不会有重复的。
 
           例如：let map = new Map();
           map.set( "a" , 1000 );
           map.set( "b" , '刘德华' );
           map.set( {age:'33'} , 2000 );
           map.set( "a" , 99 );
           map.set( NaN , NaN );
           //结果
           0: {"a" => 99}
           1: {"b" => "刘德华"}
           2: {Object => 2000}
           3: {NaN => NaN}
           //后面的a覆盖了前面的a

   4.方法：
      newMap.set( "name" , "姚明" )              //设置键名
      newMap.delete( "4rrrttttt" );                 //删除项，输入键名
      newMap.clear();                                    //清空所有的项
      newMap.forEach(（value,key,arr）);    //遍历所有的项
      newMap.has( "4rrrttttt" );                     //判断“该键名”是否存在
      newMap.get( "4rrrttttt" );                     //获取“该键名”的值
      newMap.size                                         //测量new map对象的长度，类似数组的length
    

    5.Map 和 Array的对比 
    答：
    let newMap = new Map();

         //增：newMap.set('a',1);
         //删：newMap.delete('a');
         //改：newMap.set('a',2);
         //查：newMap.has('a');

    let arr = new Array();

         //增： arr.push({'a': 2});
         //删： arr.splice( arr.findIndex( item=>item.id === 2 ) , 1 );  //或者arr.splice( arr.map( item => item.id ).indexOf( 'xxxx' ) , 1 );  //找下标
         //改： arr.forEach(item=>item.a?item.a=3:'');
         //查： arr.find(item=>item.a);


   6.去重的实例
      答：
      let newMap = new Map();
let arr = [
            {name:'tom',id:"1abb4455"},
            {name:'lisa',id:"2errrrt"},
            {name:'shasha',id:"3ewrrtggg"},
            {name:'jim',id:"4rrrttttt"},
            {name:'lisa',id:"2errrrt"},
            {name:'shasha',id:"3ewrrtggg"},
          ];
arr.map(item =>{
   newMap.set(item.id , item)
});
let brr = [];
newMap.forEach( (value,key,arr) => {
	console.log("value",value);
	console.log("key",key);
	console.log("arr",arr);
	brr.push(value);
});
console.log(brr);   //brr就是去重的结果啦

      

      new Set() 总结                                       https://www.runoob.com/w3cnote/es6-map-set.html
==========================================================================







       扩展运算符                             JS中三个点（...）是什么鬼？          答：就是 深拷贝 的意思
=======================================================================

//扩展运算符 其实就是通过遍历（类似：forEach）来拷贝、复制【对象或者数组】的每一个成员。
//理解对象的扩展运算符其实很简单，只要记住一句话就可以： 
//【对象或者数组】中的扩展运算符(...)用于遍历出当前【对象或者数组】中的所有可遍历“对象成员”，"拷贝到"新的【对象或者数组】之中。

 1.“对象”的扩展运算符.   ：  
                                              
      例子：
      let obj1 = {a:1,b:2,c:3};
      let obj2 = { ... obj1 };
      console.log(obj2);      //输出：{a: 1, b: 2, c: 3}


 2.“数组”的扩展运算符.

      例子：
      let arr1 = [{a:1},{b:2},3,4];
      let arr2 = [ ... arr1];
      console.log(arr2);    //输出 [{a:1} , {b:2} , 3, 4]



总结：扩展运算符就是简单的 深拷贝 。






     indexOf 与 findIndex   总结：都是用来找数组下标的
=================================================================

     let arr = [
            {name:'tom',id:"1abb4455"},
            {name:'lisa',id:"2errrrt"},
            {name:'shasha',id:"3ewrrtggg"},
            {name:'jim',id:"4rrrttttt"}
          ];

     let index1  = arr.map( item => item.id ).indexOf( "3ewrrtggg" );
     let index2  = arr.findIndex( item => item.name === 'jim' );
 
     console.log( index1  );
     console.log( index2  );
 
    //findIndex有点类似于map的遍历。最终返回一个所在数组的"下标"的值










 
     Object.assign    在vue当中的使用总结：
=================================================================

   语法： Object.assign(target , ...sources);     
 
   第一：assign处理对象，更新视图
              this.form = Object.assign( { } , this.form );  

  第二：assign怎么把对象或者数组添加到this当中，更新视图
            把对象或者数组分别添加到this里面去
                               let arr = [1,2,5,7];
                               let obj = {name:'中智', age:'33岁'}
                               Object.assign(this, { arr , obj });
                               console.log(this);
                              公式：就是把记得要用大括号{ }把他们括起来，才能复制到this里面去哦。




        vue视图不更新的几种情况
=================================================================
  
     第一：若一个"对象"的"属性"没有在data里面初始化注册的话，不容易更新视图。     
     

     //怎么让vue更新触动视图呢？

           ******* 方法一：********  
                      首先在data里面随便注册一个数组arr，当点击按钮的时候，把this.arr = [1,2,3] 随便等于一个数组，写进该逻辑，就能触发视图。然后把它在页面隐藏掉就行。   // <h5 v-show="false">{{ arr }}</h5>

            *******方法二：*******
                          
                          1.触动对象
                          利用Object.assign( { } , 自己本身 ),  
                          例如
                          this.form = Object.assign( { } , this.form );  
                          或者：
                           let obj = { a:11, b:22 , c:999 , d: 111};
                           this.form = Object.assign( { 空的 } , obj  );
                           console.log( this.form );                                  //输出：{ a:11, b:22 , c:999 , d: 111 }

                           2.触动数组
                              this.arr.map( item => {
                                   this.$set( item , "key" , "108" );
                               });

                          3. 把对象或者数组分别添加到this里面去
                               let arr = [1,2,5,7];
                               let obj = {name:'中智', age:'33岁'}
                               Object.assign( this ,  { arr , obj } );
                               console.log(this);
                              公式：就是把记得要用大括号{ }把他们括起来，才能复制到this里面去哦。




 


















